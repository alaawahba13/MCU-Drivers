/*
 * Led_Matrix.c
 *
 *  Created on: Mar 16, 2024
 *      Author: Alaa
 */

#include "Led_Matrix.h"

const uint8 display[43][8] = {
		{ 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C }, //0
		{ 0x10, 0x30, 0x50, 0x10, 0x10, 0x10, 0x10, 0x7c }, //1
		{ 0x7E, 0x2, 0x2, 0x7E, 0x40, 0x40, 0x40, 0x7E }, //2
		{ 0x3E, 0x2, 0x2, 0x3E, 0x2, 0x2, 0x3E, 0x0 }, //3
		{ 0x8, 0x18, 0x28, 0x48, 0xFE, 0x8, 0x8, 0x8 }, //4
		{ 0x3C, 0x20, 0x20, 0x3C, 0x4, 0x4, 0x3C, 0x0 }, //5
		{ 0x3C, 0x20, 0x20, 0x3C, 0x24, 0x24, 0x3C, 0x0 }, //6
		{ 0x3E, 0x22, 0x4, 0x8, 0x8, 0x8, 0x8, 0x8 }, //7
		{ 0x0, 0x3E, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x3E }, //8
		{ 0x3E, 0x22, 0x22, 0x3E, 0x2, 0x2, 0x2, 0x3E }, //9
		{ 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00 }, // :
		{ 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00 }, // ;
		{ 0x00, 0x02, 0x04, 0x08, 0x04, 0x02, 0x00, 0x00 }, // <
		{ 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00 }, // =
		{ 0x00, 0x20, 0x10, 0x08, 0x10, 0x20, 0x00, 0x00 }, // >
		{ 0x02, 0x01, 0x01, 0x29, 0x05, 0x03, 0x00, 0x00 }, // ?
		{ 0x3E, 0x41, 0x59, 0x55, 0x59, 0x01, 0x3E, 0x00 }, // @
		{ 0x18, 0x24, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42 }, //A
		{ 0x3C, 0x22, 0x22, 0x3c, 0x22, 0x22, 0x3C, 0x0 }, //B
		{ 0x3C, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x3C }, //C
		{ 0x7C, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x7C }, //D
		{ 0x7C, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x7C }, //E
		{ 0x7C, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x40 }, //F
		{ 0x3C, 0x40, 0x40, 0x40, 0x4c, 0x44, 0x44, 0x3C }, //G
		{ 0x44, 0x44, 0x44, 0x7C, 0x44, 0x44, 0x44, 0x44 }, //H
		{ 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7C }, //I
		{ 0x3C, 0x8, 0x8, 0x8, 0x8, 0x8, 0x48, 0x30 }, //J
		{ 0x0, 0x24, 0x28, 0x30, 0x20, 0x30, 0x28, 0x24 }, //K
		{ 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7C }, //L
		{ 0x81, 0xC3, 0xA5, 0x99, 0x81, 0x81, 0x81, 0x81 }, //M
		{ 0x0, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x0 }, //N
		{ 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C }, //O
		{ 0x3C, 0x22, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x20 }, //P
		{ 0x1C, 0x22, 0x22, 0x22, 0x22, 0x26, 0x22, 0x1D }, //Q
		{ 0x3C, 0x22, 0x22, 0x22, 0x3C, 0x24, 0x22, 0x21 }, //R
		{ 0x0, 0x1E, 0x20, 0x20, 0x3E, 0x2, 0x2, 0x3C }, //S
		{ 0x0, 0x3E, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8 }, //T
		{ 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x22, 0x1C }, //U
		{ 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18 }, //V
		{ 0x0, 0x49, 0x49, 0x49, 0x49, 0x2A, 0x1C, 0x0 }, //W
		{ 0x0, 0x41, 0x22, 0x14, 0x8, 0x14, 0x22, 0x41 }, //X
		{ 0x41, 0x22, 0x14, 0x8, 0x8, 0x8, 0x8, 0x8 }, //Y
		{ 0x0, 0x7F, 0x2, 0x4, 0x8, 0x10, 0x20, 0x7F }, //Z
		};
uint16 G_CS, G_MOSI, G_CLK;
GPIO_Registers_t *GPIOx, *CS_GPIO;
void Led_Matrix_init(SPI_Registers_t *SPIx, uint16 CS_PIN,
		GPIO_Registers_t *CS_GPIOx) {
	STK_init();
	RCC_CLK_EN(APB2_ID, GPIOA_ID);
	G_CS = CS_PIN;
	CS_GPIO = CS_GPIOx;
	if (SPIx == SPI1) {
		G_MOSI = PIN_7;
		G_CLK = PIN_5;
		GPIOx = GPIOA;
	} else if (SPIx == SPI2) {
		G_MOSI = PIN_15;
		G_CLK = PIN_13;
		GPIOx = GPIOB;
	}
	GPIO_PinConfig_t GPIO_pinConfig;
	GPIO_pinConfig.MODE = MODE_OUTPUT_PP;
	GPIO_pinConfig.Output_Speed = SPEED_10M;
	GPIO_pinConfig.Pin_Number = CS_PIN;
	GPIO_init(CS_GPIO, &GPIO_pinConfig);
	//SET CS HIGH LEVEL
	GPIO_WritePin(CS_GPIO, CS_PIN, PIN_HIGH);

	/*Configure SPI2 pins: SCK, MISO and MOSI*/

	/* SPI1 configuration */
	/* Data bytes on both MOSI and MISO lines are sent with the MSB first. Data on both MOSI
	 and MISO lines must be stable on the rising edge of the clock and can be changed on the
	 falling edge. Data is provided by the MFRC522 on the falling clock edge and is stable
	 during the rising clock edge. */
	SPI_PinConfig_t SPI_pinConfig;
	SPI_pinConfig.Commuincation_Mode = SPI_Direction_2Lines_RXTX;
	SPI_pinConfig.Data_Size = SPI_Data8;
	SPI_pinConfig.Frame_Format = SPI_Frame_MSB;
	SPI_pinConfig.BaudRate = SPI_BaudRate_256;
	SPI_pinConfig.CLK_Polarity = SPI_CLK_Polarity_0;
	SPI_pinConfig.CLK_Phase = SPI_CLK_Phase_1st;
	SPI_pinConfig.SPI_Mode = SPI_Mode_Master;
	SPI_pinConfig.NSS = SPI_NSS_Soft_set;
	SPI_pinConfig.IRQ_Enable = SPI_IRQ_EN_None;
	SPI_pinConfig.P_CallBackFun = NULL;
	SPI_init(&SPI_pinConfig, SPIx);
	SPI_GPIO_SetPins(SPIx);

	Led_Matrix_write(0x09, 0x00);       //  no decoding
	Led_Matrix_write(0x0a, 0x03);       //  brightness intensity
	Led_Matrix_write(0x0b, 0x07);       //  scan limit = 8 LEDs
	Led_Matrix_write(0x0c, 0x01);       //  power down =0,normal mode = 1
	Led_Matrix_write(0x0f, 0x00);       //  no test display

}
/*
 * 1.) Pull the CS pin LOW
 2.) Pull the clock pin LOW
 3.) Write one bit to the data pin
 4.) Pull the clock pin HIGH
 5.) Repeat steps 2,3 and 4 until both address and data bytes are written
 6.) Pull the CS pin HIGH
 * */
void Led_Matrix_writeByte(uint8 byte) {
	for (int i = 0; i < 8; i++) {
		GPIO_WritePin(GPIOx, G_CLK, PIN_LOW);  // pull the clock pin low
		GPIO_WritePin(GPIOx, G_MOSI, byte & 0x80); // write the MSB bit to the data pin
		byte = byte << 1;  // shift left
		GPIO_WritePin(GPIOx, G_CLK, PIN_HIGH);  // pull the clock pin HIGH
	}
}
void Led_Matrix_write(uint8 address, uint8 data) {
	GPIO_WritePin(CS_GPIO, G_CS, PIN_LOW);  // pull the CS pin LOW
	Led_Matrix_writeByte(address);
	Led_Matrix_writeByte(data);
	GPIO_WritePin(CS_GPIO, G_CS, PIN_HIGH);  // pull the CS pin HIGH
}
void Led_Matrix_writeString(char *str) {
	while (*str) {
		for (int i = 1; i < 9; i++) {
			Led_Matrix_write(i, display[(*str - 48)][i - 1]);
		}
		*str++;
		STK_delayMs(20000);
	}
}
